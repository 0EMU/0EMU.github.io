---
layout:     post
title:      "Real-Time Rendering, Graphics Hardware读书笔记"
subtitle:   "Graphics Hardware"
date:       2016-04-28 13:00:00
author:     "Candycat"
header-img: "img/in-post/graphics-hardware-bg.jpg"
tags:
    - Graphics Hardware
    - 读书笔记
---

[LOC]

## Chapter 18 - Graphics Hardware

尽管图形硬件变化很快，但还是有一些通用的概念架构设计。

## 18.1 缓存（Buffers and Buffering）

帧缓存的内存可能存在于和CPU同样的内存空间中（某个专用的帧缓存内存空间），也可能存在于**显存（video memory）***中。显存中包含了所有的GPU数据，但不能直接被CPU访问。颜色缓存（color buffer）是帧缓存（frame buffer）的一部分。它通过某种方式和一个**显示控制器（video controllder）**相连，显示控制器又和某个显示器相连。如下图所示。显示控制器通常包含了一个数字模拟转换器（digital-to-analog converter，DAC），数字模拟转换器负责把数字像素值转换成一个模拟信号进行显示。由于DAC需要在每一帧时对所有像素都进行转换，因此系统必须拥有很高的带宽（bandwidth）。基于CRT的设备是模拟设备（analog devices），因此它需要接受模拟输入（意味着之前需要把数字信息转换成模拟信号再传递给它进行显示）。而基于LCD的显示设备是数字设备（digital devices），但它们通常既可以接受模拟输入也可以接受数字输入。我们的个人电脑使用的是数字视频接口（digital visual interface，DVI），也被称为显示端口接口（Display Port digital interfaces），而诸如游戏系统和电视机这样的电子设备则通常使用的是高清晰度多媒体接口（high-definition multimedia interface，HDMI）。

![img](/img/in-post/simple-display-system.png)
图示：一个简单的显示系统：显示控制器负责扫描颜色缓存，得到每个像素的颜色值后将其用于控制输出设备的显示强度。

阴极射线管（CRT）显示器刷新图像的速率通常在60到120Hz/s。显示控制器的任务就是扫描整个颜色缓存，一条扫描线接着一条扫描线。显示控制器是和显示器的电子束（beam）同步工作的，也就是说它们的扫描速率是一致的（可以这样理解，显示器的电子束扫描到哪里，就会把显示屏的该区域点亮，与此同时显示控制器也按照同样的速率读取颜色缓存，并将其作为输入提供给显示器的电子束来控制显示器的显示亮度，因此两者扫描速率是同步的）。需要注意的是，电子束的移动轨迹通常是从左到右、从上到下的。因此，当电子束扫描完一行需要重新从右边移到左边扫描下一行时，这个从右移到左的过程是不会对屏幕图像产生任何影响的。这被称为**水平回扫（horizontal retrace）**。与之相关的还有**水平刷新率（horizontal refresh rate）**，这个值就是指完成一次完整的左-右-左过程所需要的时间。而**垂直回扫（vertical retrace）**就是指电子束从右下移动到左上开始扫描下一帧的过程，同样，**垂直刷新率（vertical refresh rate）**就是每秒完成这个过程的次数。当它小于72Hz时，大多数用户就会察觉到画面跳帧了。这个过程如下图所示。

![img](/img/in-post/monitor-retraces.png)
图示：显示器的水平和垂直回扫。这里显示的颜色缓存有5行。扫描线开始于左上角，然后每次会扫描一行。当扫描到一行的结尾时，它需要移动到下一行的开头。这个过程就是水平回扫。当扫描到最后的右下角时，本次扫描就结束了，就需要再移动到左上角来进行下一帧的扫描。这个移动过程被称为垂直回扫。

液晶显示器（ liquid crystal display，LCD）通常的刷新率为60Hz。而CRT需要更高的刷新率（60到120Hz）是因为当电子束移开后显示器上的磷光剂就开始逐渐变暗了（因此如果不快点的话之前扫过的就都变得很暗了）。而LCD可以持续传输光，因此不需要很高的刷新率。而且LCD也不需要回扫时间。但LCD同样有垂直同步的概念，这里的刷新率会受当前生成哪些帧的影响（笔者注：实际上应该是指液晶的响应时间）。

> 笔者注：这里再补充说明下CRT和LCD显示设备的区别。
> **CRT**的成像原理简单来说就是靠电子束逐行扫描屏幕，屏幕上的磷光剂受到电子轰击后就会短暂亮起，然后逐渐变暗。因此，如果显示器的刷新频率太低，就会造成屏幕黑屏。所以严格来说，CRT显示设备总是处于变亮-变暗-变亮的循环过程，这种一定速率黑屏并不一定是坏事，例如如果总是保持点亮状态，由于人眼的特性会自动对亮部状态做积分，因此对于运动画面会自动进行平滑处理，使得有时运动画面过于模糊。这正是LCD显示设备。**LCD**显示设备是没有变暗这一概念的。它的成像原理是向液晶通电时，液晶分子排列可以使得光线容易通过，而不通电时则分子排列混乱组织光线通过，而这些光线是由显示器的背光管提供的，背光管是持续保持发光状态的。也就是说，当没有显示信号时，LCD显示设备将总是保持当前的画面，并不会发生黑屏现象。尽管LCD设备不需要逐行扫描，可以做到快速全屏更新，但为了兼容CRT设备的工作原理，它也仍然配合视频控制器来进行逐行更新，但显然它不需要回扫时间。但是，LCD设备的显示质量（即刷新率）会受响应时间的影响。响应时间大致指的是液晶分子对电压的响应能力，当响应时间大于帧画面的更新时间时，显示器就会出现拖尾现象，这是因为液晶分子无法跟上画面的更新速度。
> 参考：http://sssa2000.github.io/blog/2014/05/19/lcd/, http://tieba.baidu.com/p/1535590985

与该话题相关的是隔行扫描（interlacing）。计算机显示器通常不是隔行扫描的，而是逐行扫描（progressive scan）的。而电视机则是隔行扫描的，也就是说，在一次垂直刷新过程中，奇数行会被绘制，然后在下一个刷新过程中，偶数行会被绘制。

> 笔者注：我们很容易联想到**垂直同步**的事情，这里也补充说明下。
> 提到垂直同步，不得不提到[画面撕裂](https://en.wikipedia.org/wiki/Screen_tearing)，这是提出垂直同步的动机。如下图所示，画面撕裂其实就是显示器在显示画面时读取了多个帧画面。这是因为，显示器和帧缓存个更新其实是异步的，当视频控制器还在扫描当前帧缓存中的像素时，显卡已经完成了新一帧的绘制并更新了帧缓存，导致视频控制器对于到了不同帧的颜色数据。也就是说，当GPU的帧渲染速率大于显示设备的刷新率时，就有可能会出现画面撕裂。当然，如果当渲染速率远大于刷新率时撕裂可能也不会非常明显，因为刷新屏幕时使用了多个帧画面使得每个撕裂条都不是那么明显。
> 我们已经知道了画面撕裂是由于显卡和显示器之间的异步造成，那么解决方法就是同步它们，也就是多重缓存和[垂直同步](https://en.wikipedia.org/wiki/Vertical_synchronization)。当开启了垂直同步后，只有在显示器完成了当前的刷新工作后，显卡才能进行任何对显示缓存的显示工作。具体来说，在显示设备每次垂直回扫（也被称为VBlank）时，才可以被允许快速更换双缓冲之间的内容（假定使用的是双缓存技术）或是在两者之间完成一次交换（假定使用的是页面翻转的功能）。这样就可以保证显示器在刷新时总是读取到同一个帧缓存中的数据。需要注意的是，垂直同步只是阻塞了显卡的present方法。
> 然而，开启垂直同步虽然可以解决画面撕裂的问题但也引入了新的问题。最大的问题就是帧率下降的问题。由于开启垂直同步后，渲染的实际更新速率将受显示设备刷新速率的限制，也就是说如果一个显示设备的刷新率为60帧，那么渲染的更新速率也不会超过60帧。关键是，这个渲染速率可能会远小于显示设备的更新速率，造成画面卡顿。出现这种现象的原因是，我们的显卡常常会miss掉垂直同步的机会，造成总是无法及时更新画面。在[这篇文章](http://blog.uwa4d.com/archives/presentandsync.html)里，作者把这个过程比喻成搭乘地铁。“一般来说，地铁到达每一站的时间均是平均且一定的，假设每10分钟一班接走一批乘客。但是几乎没有多少乘客可以按点到达，如果提前两分钟到达，则只需要等待两分钟即可乘上地铁，但是，如果你错过了，哪怕只差了一分钟，那么你也不得不再等待九分钟才能乘上地铁。”对应到这里，地铁到站相当于垂直回扫的时间到了，我们需要交换双缓存里的内容来进行画面更新，但此时乘客还没有到（渲染还没有完成），那么本次渲染就错过了更新时机，只能等待下一次地铁到站了。这样的情况多了，就会造成帧率大幅下降，尤其是本来渲染速率就小于显示设备的刷新速率时还要等待这就很捉急了。
> Nvidia提出了一种自适应同步（Adaptive Vsync）的方法，当渲染引擎的渲染速率大于显示设备的刷新速率时就自动开启垂直同步，否则就关闭。

![img](/img/in-post/monitor-retraces.png)